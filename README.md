# centroFlye

### Version 0.5 (initial release)
## Overview
centroFlye is an algorithm for centromere assembly using long error-prone reads.
Here we show how to apply it for assembling the human X centromere.
 
**Disclaimer:** all code in this repository is under heavy development.
Please expect significant changes and updates in the nearest future.
Certain steps of the algorithm are highly computationally and/or memory intensive in the current version.


## Availability
Final assembly and intermediate results are published at ZENODO. TODO
You can download them by running the following script TODO


## Dependencies
### Python packages (preferrably latest versions):
+ [Biopython](https://pypi.org/project/biopython/)
+ [Edlib](https://pypi.org/project/edlib/)
+ [Networkx](https://pypi.org/project/networkx/)
+ [Numpy](https://pypi.org/project/numpy/)
+ [Regex](https://pypi.org/project/regex/)

### External software
+ [Flye](https://github.com/fenderglass/Flye) (v2.4.2)
+ [Noise Cancelling Repeat Finder (NCRF)](https://github.com/makovalab-psu/NoiseCancellingRepeatFinder)


## Tutorial
In this manual we go step-by-step demonstrating centroFlye algorithm.
The detailed information about the algorithm can be found in the paper.

Please, run all commands from the root of the repository.

### 1. Recruitment of centromeric reads

We use 50x ultra-long Oxford Nanopore dataset generated by [Telomere2Telomere Consorsium](https://github.com/nanopore-wgs-consortium/CHM13). 
This step is run directly on the reads at the [link](https://s3.amazonaws.com/nanopore-human-wgs/chm13/nanopore/rel2/rel2.fastq.gz).
The following bash script splits the input file in 50 files and runs DXZ1-based recruitment in 50 threads.
DXZ1 is supplied in this repo (``supplementary_data/DXZ1_rc.fasta``).
The result of this step is a fasta file (TODO put ZENODO link) with centromeric reads that are stored at ``results/centromeric_reads/centromeric_reads.fasta``.

From the root of the project run 
```
make -C scripts/read_recruitment
```
and start recruitment (`<path_to_CHM13>` is where the ONT reads are located):
```
bash scripts/read_recruitment/run_read_recruitment.sh \
              <path_to_CHM13>/rel2.fastq.gz \
              results/centromeric_reads 50 11100000
```

### 2. Partitioning centromeric reads into units, where each unit represents a HOR copy
At this step we are utilizing centromeric reads from step 1 and run NCRF on them (``<path_to_NCRF>`` is where NCRF binary is located).
The result of this step is NCRF report on all centromeric reads (TODO put ZENODO link) that is stored at ``results/NCRF_rc/report.ncrf``.
The following command uses 50 threads.

```
python scripts/run_ncrf_parallel.py \
            --reads results/centromeric_reads/centromeric_reads.fasta \
            -t 50 \
            --outdir results/NCRF_rc \
            --repeat supplementary_data/DXZ1_rc.fasta \
            --ncrf-bin <path_to_NCRF>/NCRF
```

### 3. Recruitment of unique k-mers
At this step we first recruit rare 19-mers and then use distance graph to filter out non-unique 19-mers (details can be found in the paper).
Current implementation requires around 1TB of RAM.
If you do not wish to run it yourself, the result is available at ZENODO: (TODO put link).
The following command uses NCRF reports from step 2 and reports unique kmers to ``results/recruited_unique_kmers/unique_kmers_min_edge_cov_5_RC.txt``.

```
bash scripts/unique_kmer_recruitment/unique_kmer_recruitment.sh \
              results/NCRF_rc/report.ncrf \
              results/recruited_unique_kmers
```

### 4. DXZ1 array resolution (main part)
At this step we use partitioning of reads into units provided by NCRF at step 2 and unique 19-mer recruited at step 3.
Note, that this step only reports the "placement" of centromeric reads in the (yet unknown) sequence of centromere X (details can be found in the paper).
The resulting placement is available at ``results/tr_resolution/read_positions.csv``.
The result of this step is available at the ZENODO.

```
python scripts/read_placer.py \
              --ncrf results/NCRF_rc/report.ncrf \
              --genomic-kmers results/recruited_unique_kmers/unique_kmers_min_edge_cov_5_RC.txt \
              --outdir results/tr_resolution
```

### 5. Obtaining a polished version of DXZ1 (DXZ1* in the paper)
At this step we derive a polished version of DXZ1 unit (called DXZ1*) that is supported by centromeric reads.
We utilze NCRF report obtained at step 2.
After running this step, DXZ1* is located at ``supplementary_data/DXZ1_rc_star.fasta``.

```
python scripts/better_consensus_unit_reconstruction.py \
              --reads-ncrf results/NCRF_rc/report.ncrf \
              --unit supplementary_data/DXZ1_rc.fasta \
              --output supplementary_data/DXZ1_rc_star.fasta
```

### 6. Polishing
At this step we finally polish the constructed cenX sequence.
After running this step, the final assembly is located at ``results/polishing/final_sequence_2.fasta``.

```
python scripts/eltr_polisher.py \
              --read-placement results/tr_resolution/tr_resolution_5_RC_freqkmers2/read_positions.csv \
              --outdir results/polishing \
              --ncrf results/NCRF_rc/report.ncrf \
              --output-progress \
              --error-mode nano \
              --num-iters 2 \
              --num-threads 50 \
              --unit supplementary_data/DXZ1_rc_star.fasta
```

## Publications
Bzikadze A., Pevzner P.A. centroFlye: Assembling Centromeres with Long Error-Prone Reads, 2019, bioRxiv TODO add DOI

## Contacts
Please report any problems to the [issue tracker](https://github.com/seryrzu/centroFlye/issues).
Alternatively, you can write directly to [abzikadze@ucsd.edu](mailto:abzikadze@ucsd.edu).
